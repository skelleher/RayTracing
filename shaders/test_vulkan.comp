#version 450
#extension GL_ARB_separate_shader_objects : enable

// For details on GLSL layout syntax see: https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)

// TODO: use specialization constants to configure the shader at pipeline construction time
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout(std140, binding = 0) uniform UniformBufferObject {
    uint outputWidth;
    uint outputHeight;
} ubo;

struct Pixel{
  vec4 value;
};

layout(std140, binding = 1) buffer buf
{
   Pixel imageData[];
};

void main() {
    uint width = ubo.outputWidth;
    uint height = ubo.outputHeight;

    //  In order to fit the work into workgroups, some unnecessary threads are launched.
    //  We terminate those threads here. 
    if(gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height)
        return;

    float x = float(gl_GlobalInvocationID.x) / float(width);
    float y = float(gl_GlobalInvocationID.y) / float(height);

    // Render each tile in a different color, with red outline
    vec4 _color = vec4(255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 255.0 * float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y), 255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 1);
    if (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0)
    {
        _color = vec4(255, 0, 0, 1);
    }

    imageData[width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].value = _color;

    return;
}
