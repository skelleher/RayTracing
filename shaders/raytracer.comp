#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shader_clock : enable

#include "raytracer_glsl.h"

//#define DIFFUSE_SHADE
//#define NORMAL_SHADE
#define MATERIAL_SHADE

#define FLT_MAX 3.402823466e+38
#define FLT_MIN 1.175494351e-38
#define DBL_MAX 1.7976931348623158e+308
#define DBL_MIN 2.2250738585072014e-308

// Must match enum material_type_t in material.h
const uint MATERIAL_NONE    = 0;
const uint MATERIAL_DIFFUSE = 1;
const uint MATERIAL_METAL   = 2;
const uint MATERIAL_GLASS   = 3;

struct ray {
    vec3 origin;
    vec3 direction;
};

struct hit_info_t {
    float dist;
    vec3  point;
    vec3  normal;
    uint  materialID;
};

// For details on GLSL layout syntax see: https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)

// TODO: use specialization constants to configure the shader at pipeline construction time
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

ray _cameraGetRay( float u, float v );

vec3 _blockColor( uint blockID, uint totalBlocks );
vec3 _randomColor( float u, float v );
vec3 _gradient( float u, float v );
vec3 _background( const ray r );
vec3 _sky( float u, float v );

vec3 _color( const ray r, uint max_depth );
bool _sceneHit( const ray r, float t_min, float t_max, out hit_info_t p_hit );
bool _sphereHit( const ray r, const sphere_glsl_t sphere, float t_min, float t_max, out hit_info_t p_hit );
bool _materialScatter( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered );
bool _diffuseScatter ( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered );
bool _metalScatter   ( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered );
bool _glassScatter   ( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered );

vec3  _pointOnRay( const ray r, float dist );
vec3  _reflect( const vec3 v, const vec3 normal );
bool  _refract( const vec3 v, const vec3 normal, float ni_over_nt, out vec3 refracted );
float _schlick( float cosine, float refractionIndex );

void  _randomInit( uint seed );
vec3  _randomInUnitSphere();
vec3  _randomOnUnitDisk();
float _random();


void main() {
    uint width = ubo.outputWidth;
    uint height = ubo.outputHeight;

    //  In order to fit the work into workgroups, some unnecessary threads are launched.
    //  We terminate those threads here. 
    if (gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height)
        return;

    _randomInit( ubo.clock_ticks );

    uint blockID     = uint( gl_WorkGroupID.x + gl_WorkGroupID.y + gl_WorkGroupID.z );
    uint totalBlocks = uint( gl_NumWorkGroups.x + gl_NumWorkGroups.y + gl_NumWorkGroups.z );

    float u = float(gl_GlobalInvocationID.x) / float(width);
    float v = float(gl_GlobalInvocationID.y) / float(height);
    vec4 color = vec4(0,0,0,1);

    // Render each tile in a different color, with red outline
    if (ubo.debug) {
        if (ubo.monochrome) {
            color = vec4(u*v, u*v, u*v, 1);
        } else {
            color = vec4(255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 255.0 * float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y), 255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 1);
        }

        if (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0)
        {
            color = vec4(255, 0, 0, 1);
        }
    }
    else
    {
        for ( uint s = 0; s < ubo.num_aa_samples; s++ )
        {
            ray r = _cameraGetRay( u, v );

            vec3 _sample  = _color( r, ubo.max_ray_depth );
            //vec3 _sample = _blockColor( blockID, totalBlocks );
            //vec3 _sample = _randomColor( u, v );
            //vec3 _sample = _gradient( u, v );
            //vec3 _sample = _sky( u, v );
            //vec3 _sample = _background( r );

            color.r += _sample.r;
            color.g += _sample.g;
            color.b += _sample.b;
        }

        color.r /= ubo.num_aa_samples;
        color.g /= ubo.num_aa_samples;
        color.b /= ubo.num_aa_samples;
    }

    // Apply 2.0 Gamma correction
    if (ubo.applyGammaCorrection)
        color = vec4( sqrt( color.r ), sqrt( color.g ), sqrt( color.b ), 1.0 );

    // Test for bad struct alignment (happens if the programmer forgets to align every field)
    if (ubo.magic != 0xDEADBEEF)
        color = vec4(1,0,1,1);

    imageData[width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].rgba = color;
}



//
// Renderer
//

vec3 _color( const ray r, uint max_depth )
{
    hit_info_t hit;
    vec3            attenuation;
    ray             scattered = r;
    vec3            color = vec3( 1.0f, 1.0f, 1.0f );

    for ( uint i = 0; i < max_depth; i++ ) {
        if ( _sceneHit( scattered, 0.001f, FLT_MAX, hit ) ) {
#if defined( NORMAL_SHADE )
            vec3 normal;
            vec3 p = _pointOnRay( r, hit.dist );
            normal.x = p.x - 0;
            normal.y = p.y - 0;
            normal.z = p.z = -1;
            normal = normalize( normal );
            normal.x = 0.5f * (normal.x + 1.0f);
            normal.y = 0.5f * (normal.y + 1.0f);
            normal.z = 0.5f * (normal.z + 1.0f);
            return normal;
#elif defined( DIFFUSE_SHADE )
            vec3 randBounce = _randomInUnitSphere();

            vec3 target;
            target.x = hit.point.x + hit.normal.x + randBounce.x;
            target.y = hit.point.y + hit.normal.y + randBounce.y;
            target.z = hit.point.z + hit.normal.z + randBounce.z;

            ray s;
            s.origin      = hit.point;
            s.direction.x = target.x - hit.point.x;
            s.direction.y = target.y - hit.point.y;
            s.direction.z = target.z - hit.point.z;
            scattered = s;

            color.x = color.x * 0.5f;
            color.y = color.y * 0.5f;
            color.z = color.z * 0.5f;
#else
            if ( _materialScatter( scattered, hit.materialID, hit, attenuation, scattered ) ) {
                color *= attenuation;
            } else {
                break;
            }
#endif
        } else {
            color *= _background( scattered );
            break;
        }
    }

    return color;
}


bool _sphereHit( const ray r, const sphere_glsl_t sphere, float t_min, float t_max, out hit_info_t p_hit )
{
    vec3 oc;
    oc.x = r.origin.x - sphere.center_x;
    oc.y = r.origin.y - sphere.center_y;
    oc.z = r.origin.z - sphere.center_z;

    float a = dot( r.direction, r.direction );
    float b = dot( oc, r.direction );
    float c = dot( oc, oc ) - ( sphere.radius * sphere.radius );

    float discriminant = b * b - a * c;

    if ( discriminant > 0 ) {
        float t = ( -b - sqrt( discriminant ) ) / a;
        if ( t < t_max && t > t_min ) {
            p_hit.dist = t;
            p_hit.point    = _pointOnRay( r, t );
            p_hit.normal.x = ( p_hit.point.x - sphere.center_x ) / sphere.radius;
            p_hit.normal.y = ( p_hit.point.y - sphere.center_y ) / sphere.radius;
            p_hit.normal.z = ( p_hit.point.z - sphere.center_z ) / sphere.radius;
#ifdef MATERIAL_SHADE
            p_hit.materialID = sphere.materialID;
#endif
            return true;
        }

        t = ( -b + sqrt( discriminant ) ) / a;
        if ( t < t_max && t > t_min ) {
            p_hit.dist = t;
            p_hit.point    = _pointOnRay( r, t );
            p_hit.normal.x = ( p_hit.point.x - sphere.center_x ) / sphere.radius;
            p_hit.normal.y = ( p_hit.point.y - sphere.center_y ) / sphere.radius;
            p_hit.normal.z = ( p_hit.point.z - sphere.center_z ) / sphere.radius;
#ifdef MATERIAL_SHADE
            p_hit.materialID = sphere.materialID;
#endif
            return true;
        }
    }

    return false;
}


bool  _sceneHit( const ray r, float t_min, float t_max, out hit_info_t p_hit )
{
    bool     rval         = false;
    float    closestSoFar = t_max;
    hit_info_t hit;

    for ( int i = 0; i < ubo.sceneSize; i++ ) {
        hit_info_t tmp;
        sphere_glsl_t sphere = scene[i];
        if ( _sphereHit( r, sphere, t_min, closestSoFar, tmp ) ) {
            rval         = true;
            closestSoFar = tmp.dist;
            hit          = tmp;
        }
    }

    p_hit = hit;

    return rval;
}


//
// Material implementations
//


bool _materialScatter( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered )
{
    bool rval = false;

    switch ( materials[materialID].type ) {
        case MATERIAL_DIFFUSE:
            rval = _diffuseScatter( r, materialID, hit, p_attenuation, p_scattered );
            break;

        case MATERIAL_METAL:
            rval = _metalScatter( r, materialID, hit, p_attenuation, p_scattered );
            break;

        case MATERIAL_GLASS:
            rval = _glassScatter( r, materialID, hit, p_attenuation, p_scattered );
            break;
    }

    return rval;
}


bool _diffuseScatter( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered )
{
    vec3 target    = hit.point + hit.normal;
    target = target + _randomInUnitSphere();
    vec3 hit_point = hit.point;

    ray scatter;
    scatter.origin = hit.point;
    scatter.direction = target.xyz - hit_point.xyz;

    p_scattered     = scatter;
    p_attenuation.r = materials[materialID].albedo_r;
    p_attenuation.g = materials[materialID].albedo_g;
    p_attenuation.b = materials[materialID].albedo_b;

    return true;
}


bool _metalScatter( const ray r,  uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered )
{
    vec3 direction = normalize( r.direction );
    vec3 reflected = _reflect( direction, hit.normal );

    ray scatter;
    scatter.origin = hit.point;
    scatter.direction = reflected.xyz + ( materials[materialID].blur * _randomInUnitSphere() );

    p_scattered     = scatter;
    p_attenuation.r = materials[materialID].albedo_r;
    p_attenuation.g = materials[materialID].albedo_g;
    p_attenuation.b = materials[materialID].albedo_b;

    float d = dot( p_scattered.direction, hit.normal );

    return ( d > 0 );
}


bool _glassScatter( const ray r, uint materialID, const hit_info_t hit, out vec3 p_attenuation, out ray p_scattered )
{
    vec3  outwardNormal;
    vec3  reflected = _reflect( r.direction, hit.normal );
    float niOverNt;
    vec3  refracted;
    float probability;
    float cosine;

    // no color shift; "white" glass
    p_attenuation.r = 1.0;
    p_attenuation.g = 1.0;
    p_attenuation.b = 1.0;

    if ( dot( r.direction, hit.normal ) > 0 ) {
        outwardNormal = -hit.normal;
        niOverNt      = materials[materialID].refractionIndex;
        cosine        = materials[materialID].refractionIndex * dot(r.direction, hit.normal ) / length( r.direction );
    } else {
        outwardNormal = hit.normal;
        niOverNt      = 1.0f / materials[materialID].refractionIndex;
        cosine        = (-1 * dot(r.direction, hit.normal ) ) / length( r.direction );
    }

    if ( _refract( r.direction, outwardNormal, niOverNt, refracted ) ) {
        probability = _schlick( cosine, materials[materialID].refractionIndex );
    } else {
        probability = 1.0f;
    }

    float p = _random();

    if ( p < probability ) {
        ray scatter;
        scatter.origin = hit.point;
        scatter.direction = reflected;
        p_scattered = scatter;
    } else {
        ray scatter;
        scatter.origin = hit.point;
        scatter.direction = refracted;
        p_scattered = scatter;
    }

    return true;
}



//
// Camera functions
//

ray _cameraGetRay( float s, float t )
{
    vec3 rand   = ubo.camera.lensRadius * _randomOnUnitDisk(); // calling _randomOnUnitDisk() cuts frame rate in half
    vec3 offset = ubo.camera.u * rand.x + ubo.camera.v * rand.y;

    vec3 origin    = vec3( ubo.camera.origin.x + offset.x, ubo.camera.origin.y + offset.y, ubo.camera.origin.z + offset.z );

    vec3 direction;
    direction.x = ubo.camera.leftCorner.x + ( s * ubo.camera.horizontal.x ) + ( ( 1.0f - t ) * ubo.camera.vertical.x ) - ubo.camera.origin.x - offset.x;
    direction.y = ubo.camera.leftCorner.y + ( s * ubo.camera.horizontal.y ) + ( ( 1.0f - t ) * ubo.camera.vertical.y ) - ubo.camera.origin.y - offset.y;
    direction.z = ubo.camera.leftCorner.z + ( s * ubo.camera.horizontal.z ) + ( ( 1.0f - t ) * ubo.camera.vertical.z ) - ubo.camera.origin.z - offset.z;

    ray r;
    r.origin = origin;
    r.direction = direction;

    return r;
}


vec3 _blockColor( uint blockID, uint totalBlocks )
{
    float c = float(blockID) / float(totalBlocks);
    vec3 color = vec3( c, c, c );

    return color;
}


vec3 _randomColor( float u, float v )
{
    float c = _random();
    vec3 color = vec3( c, c, c );

    return color;
}


vec3 _gradient( float u, float v )
{
    float r = u;
    float g = v;
    float b = 0.2f;

    vec3 color = vec3( r, g, b );

    return color;
}


vec3 _background( const ray r )
{
    vec3  unitDirection = normalize( r.direction );
    float t             = 0.5f * ( unitDirection.y + 1.0f );

    //return ( 1.0f - t ) * vec3( 1.0f, 1.0f, 1.0f ) + t * vec3( 0.5f, 0.7f, 1.0f );

    vec3 v1 = vec3( 1.0f, 1.0f, 1.0f );
    vec3 v2 = vec3( 0.5f, 0.7f, 1.0f );

    vec3 color;
    color.r = (1.0f - t) * v1.x + t * v2.x;
    color.g = (1.0f - t) * v1.y + t * v2.y;
    color.b = (1.0f - t) * v1.z + t * v2.z;

    return color;
}


vec3 _sky( float u, float v )
{
    vec3 horizontal = vec3( 4, 0, 0 );
    vec3 vertical   = vec3( 0, 2, 0 );
    vec3 origin     = vec3( 0, 0, 0 );
    vec3 leftCorner = vec3( -2, -1, -1 );

    ray r;
    r.origin      = origin;
    r.direction.x = leftCorner.x + u * horizontal.x + v * vertical.x;
    r.direction.y = leftCorner.y + u * horizontal.y + v * vertical.y;
    r.direction.z = leftCorner.z + u * horizontal.z + v * vertical.z;

    vec3 unit_direction = normalize( r.direction );
    float t = 0.5f * (unit_direction.y + 1.0f);
    vec3 v1 = vec3( 1, 1, 1 );
    vec3 v2 = vec3( 0.5f, 0.7f, 1.0f );
    vec3 color;
    color.x = (1.0 - t) * v1.x + t * v2.x;
    color.y = (1.0 - t) * v1.y + t * v2.y;
    color.z = (1.0 - t) * v1.z + t * v2.z;

    return color;
}




//
// Utils
//

uint _seed;
void _randomInit( uint seed )
{
    uint threadIndex = (gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * gl_GlobalInvocationID.z) + gl_LocalInvocationIndex; //gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID;
    _seed = (seed << threadIndex ) + threadIndex;
}


uint xorrand( uint seed )
{
    // Xorshift algorithm from George Marsaglia's paper
    seed ^= ( seed << 13 );
    seed ^= ( seed >> 17 );
    seed ^= ( seed << 5 );

    return seed;
}


uint wanghash( uint seed )
{
    seed = ( seed ^ 61 ) ^ ( seed >> 16 );
    seed *= 9;
    seed = seed ^ ( seed >> 4 );
    seed *= 0x27d4eb2d;
    seed = seed ^ ( seed >> 15 );
    return seed;
}


float _random()
{
    _seed = wanghash( _seed );
    _seed = xorrand( _seed );

    // Generate a random float in [0, 1)...
    float f = float(_seed) * ( 1.0 / 4294967296.0 );

    return f;
}


vec3 _pointOnRay( const ray r, float dist )
{
    vec3 p;
    p.x = r.origin.x + (r.direction.x * dist);
    p.y = r.origin.y + (r.direction.y * dist);
    p.z = r.origin.z + (r.direction.z * dist);

    return p;
}


//--------------------------------------------------------------

vec3 _randomInUnitSphere()
{
    vec3 v;
    v.x = _random();
    v.y = _random();
    v.z = _random();

    return v;
}


vec3 _randomOnUnitDisk()
{
    vec3 point;
//    uint maxTries = 10;
    uint maxTries = 1;
    do {
        vec3 v1 = vec3( _random(), _random(), 0.0f );
        vec3 v2 = vec3( 1.0f, 1.0f, 0.0f );

        point.x = 2.0f * v1.x - v2.x;
        point.y = 2.0f * v1.y - v2.y;
        point.z = 2.0f * v1.z - v2.z;
    } while ( dot( point, point ) >= 1.0f && maxTries-- >= 0 );

    return point;
}


vec3 _reflect( const vec3 v, const vec3 normal )
{
    return v.xyz - 2 * dot( v,  normal ) * normal.xyz;
}


bool _refract( const vec3 v, const vec3 normal, float ni_over_nt, out vec3 refracted )
{
    vec3  _v           = normalize( v );
    float dt           = dot( _v,  normal );
    float discriminant = 1.0f - ni_over_nt * ni_over_nt * ( 1.0f - dt * dt );

    if ( discriminant > 0 ) {
        float sqrt_d = sqrt( discriminant );
        vec3 tmp;
        tmp.x = ni_over_nt * (_v.x - normal.x * dt) - normal.x * sqrt_d;
        tmp.y = ni_over_nt * (_v.y - normal.y * dt) - normal.y * sqrt_d;
        tmp.z = ni_over_nt * (_v.z - normal.z * dt) - normal.z * sqrt_d;
        refracted = tmp;

        return true;
    } else {
        return false;
    }
}


float _schlick( float cosine, float refractionIndex )
{
    float r0 = ( 1.0f - refractionIndex ) / ( 1.0f + refractionIndex );
    r0       = r0 * r0;

    return r0 + ( 1.0f - r0 ) * pow( ( 1.0f - cosine ), 5 );
}

