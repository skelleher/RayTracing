#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shader_clock : enable
//#extension GL_ARB_gpu_shader_int64: enable

#include "raytracer_glsl.h"

// For details on GLSL layout syntax see: https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)

// TODO: use specialization constants to configure the shader at pipeline construction time
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

ray _cameraGetRay( float u, float v );

vec3 _blockColor( uint blockID, uint totalBlocks );
vec3 _randomColor( float u, float v );
vec3 _gradient( float u, float v );
vec3 _background( const ray r );
vec3 _sky( float u, float v );

//vec3 _color( const ray r, const sphere_glsl_t scene[ubo.sceneSize], const material_t materials[ubo.sceneSize], uint sceneSize, uint max_depth );
//bool _sceneHit( const ray r, const sphere_glsl_t[ubo.sceneSize] scene, uint sceneSize, float t_min, float t_max, out hit_info hit );
//bool _sphereHit( const ray r, const sphere_glsl_t sphere, uint sphereID, float t_min, float t_max, out hit_info hit );
//bool _materialScatter( const ray r, const material_t[ubo.sceneSize] materials, uint materialID, const hit_info hit, out vec3 attenuation, out ray scattered );
//bool _diffuseScatter ( const ray r, const material_t[ubo.sceneSize] materials, uint materialID, const hit_info hit, out vec3 attenuation, out ray scattered );
//bool _metalScatter   ( const ray r, const material_t[ubo.sceneSize] materials, uint materialID, const hit_info hit, out vec3 attenuation, out ray scattered );
//bool _glassScatter   ( const ray r, const material_t[ubo.sceneSize] materials, uint materialID, const hit_info hit, out vec3 attenuation, out ray scattered );

vec3 _color( const ray r, /*const sphere_glsl_t scene[ubo.sceneSize], const material_t materials[ubo.sceneSize], uint sceneSize,*/ uint max_depth );
bool _sceneHit( const ray r, /*const sphere_glsl_t[ubo.sceneSize] scene, uint sceneSize,*/ float t_min, float t_max, out hit_info_glsl_t hit );
bool _sphereHit( const ray r, /*const sphere_glsl_t sphere, uint sphereID,*/ float t_min, float t_max, out hit_info_glsl_t hit );
bool _materialScatter( const ray r, /*const material_t[ubo.sceneSize] materials,*/ uint materialID, const hit_info_glsl_t hit, out vec3 attenuation, out ray scattered );
bool _diffuseScatter ( const ray r, /*const material_t[ubo.sceneSize] materials,*/ uint materialID, const hit_info_glsl_t hit, out vec3 attenuation, out ray scattered );
bool _metalScatter   ( const ray r, /*const material_t[ubo.sceneSize] materials,*/ uint materialID, const hit_info_glsl_t hit, out vec3 attenuation, out ray scattered );
bool _glassScatter   ( const ray r, /*const material_t[ubo.sceneSize] materials,*/ uint materialID, const hit_info_glsl_t hit, out vec3 attenuation, out ray scattered );

vec3  _reflect( const vec3 v, const vec3 normal );
bool  _refract( const vec3 v, const vec3 normal, float ni_over_nt, out vec3 refracted );
float _schlick( float cosine, float refractionIndex );

void  _randomInit( uint seed );
vec3  _randomInUnitSphere();
vec3  _randomOnUnitDisk();
float _random();


void main() {
    uint width = ubo.outputWidth;
    uint height = ubo.outputHeight;

    //  In order to fit the work into workgroups, some unnecessary threads are launched.
    //  We terminate those threads here. 
    if(gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height)
        return;

    float u = float(gl_GlobalInvocationID.x) / float(width);
    float v = float(gl_GlobalInvocationID.y) / float(height);
    vec4 color;

    // Render each tile in a different color, with red outline
    if (ubo.debug) {
        if (ubo.monochrome) {
            color = vec4(u*v, u*v, u*v, 1);
        } else {
            color = vec4(255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 255.0 * float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y), 255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 1);
        }

        if (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0)
        {
            color = vec4(255, 0, 0, 1);
        }
    }

    uint blockID     = uint( gl_WorkGroupID.x + gl_WorkGroupID.y + gl_WorkGroupID.z );
    uint totalBlocks = uint( gl_NumWorkGroups.x + gl_NumWorkGroups.y + gl_NumWorkGroups.z );

    //color.rgb = _blockColor( blockID, totalBlocks );
    //color.rgb = _randomColor( u, v );
    //color.rgb = _gradient( u, v );
    color.rgb = _sky( u, v );

    // Apply 2.0 Gamma correction
    if (ubo.applyGammaCorrection)
        color = vec4( sqrt( color.r ), sqrt( color.g ), sqrt( color.b ), 1.0 );

    // Test for bad struct alignment (happens if the programmer forgets to align every field)
    if (ubo.magic != 0xDEADBEEF)
        color = vec4(1,0,1,1);

    imageData[width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].rgba = color;
}


//
// Utils
//

//double dseed = 1.0;
//double drand48( const vec3 v )
//{
//    double d     = 12.9898 * v.x + 78.233 * v.y;
//    double x     = sin( d ) * 43758.5453;
//    double fract = x - floor( x );
//    double rval  = 2.0 * (fract)-1.0;
//    rval         = ( 1.0 - abs( rval * dseed ) );
//
//    dseed = rval;
//
//    return rval;
//}

float _random()
{
    uint x = gl_GlobalInvocationID.x * WORKGROUP_SIZE + gl_WorkGroupID.x;
    uint y = gl_GlobalInvocationID.y * WORKGROUP_SIZE + gl_WorkGroupID.y;

    vec2 n = vec2(x, y);

	float r = fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);

    return r;
}

//float xorrand( uint seed )
//{
//    // Xorshift algorithm from George Marsaglia's paper
//    seed ^= ( seed << 13 );
//    seed ^= ( seed >> 17 );
//    seed ^= ( seed << 5 );
//
//    return seed;
//}
//
//uint wanghash( uint seed )
//{
//    seed = ( seed ^ 61 ) ^ ( seed >> 16 );
//    seed *= 9;
//    seed = seed ^ ( seed >> 4 );
//    seed *= 0x27d4eb2d;
//    seed = seed ^ ( seed >> 15 );
//    return seed;
//}

//float _random()
//{
//    uint x = gl_GlobalInvocationID.x * WORKGROUP_SIZE + gl_WorkGroupID.x;
//    uint y = gl_GlobalInvocationID.y * WORKGROUP_SIZE + gl_WorkGroupID.y;
//
//    //int64 foo = clockARB();
//
//    uint seed = 1;
//    seed = wanghash( x + y * uint(clockARB()) );
//    seed = uint(xorrand( seed ));
//    // Generate a random float in [0, 1)...
//    float f = float( seed ) * ( 1.0 / 4294967296.0 );
//
//    return f;
//}



//
// Renderer
//


vec3 _blockColor( uint blockID, uint totalBlocks )
{
    float c = float(blockID) / float(totalBlocks);
    vec3 color = vec3( c, c, c );

    return color;
}


vec3 _randomColor( float u, float v )
{
    float c = _random();
    vec3 color = vec3( c, c, c );

    return color;
}


vec3 _gradient( float u, float v )
{
    float r = u;
    float g = v;
    float b = 0.2f;

    vec3 color = vec3( r, g, b );

    return color;
}


vec3 _background( const ray r )
{
    vec3  unitDirection = normalize( r.direction );
    float t             = 0.5f * ( unitDirection.y + 1.0f );

    //return ( 1.0f - t ) * vec3( 1.0f, 1.0f, 1.0f ) + t * vec3( 0.5f, 0.7f, 1.0f );

    vec3 v1 = vec3( 1.0f, 1.0f, 1.0f );
    vec3 v2 = vec3( 0.5f, 0.7f, 1.0f );

    vec3 color;
    color.r = (1.0f - t) * v1.x + t * v2.x;
    color.g = (1.0f - t) * v1.y + t * v2.y;
    color.b = (1.0f - t) * v1.z + t * v2.z;

    return color;
}


vec3 _sky( float u, float v )
{
    vec3 horizontal = vec3( 4, 0, 0 );
    vec3 vertical   = vec3( 0, 2, 0 );
    vec3 origin     = vec3( 0, 0, 0 );
    vec3 leftCorner = vec3( -2, -1, -1 );

    ray r;
    r.origin      = origin;
    r.direction.x = leftCorner.x + u * horizontal.x + v * vertical.x;
    r.direction.y = leftCorner.y + u * horizontal.y + v * vertical.y;
    r.direction.z = leftCorner.z + u * horizontal.z + v * vertical.z;

    vec3 unit_direction = normalize( r.direction );
    float t = 0.5f * (unit_direction.y + 1.0f);
    vec3 v1 = vec3( 1, 1, 1 );
    vec3 v2 = vec3( 0.5f, 0.7f, 1.0f );
    vec3 color;
    color.x = (1.0 - t) * v1.x + t * v2.x;
    color.y = (1.0 - t) * v1.y + t * v2.y;
    color.z = (1.0 - t) * v1.z + t * v2.z;

    return color;
}


