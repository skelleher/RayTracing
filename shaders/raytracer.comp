#version 450
#extension GL_ARB_separate_shader_objects : enable


#include "raytracer_glsl.h"

// For details on GLSL layout syntax see: https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)

// TODO: use specialization constants to configure the shader at pipeline construction time
#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;


void main() {
    uint width = ubo.outputWidth;
    uint height = ubo.outputHeight;

    //  In order to fit the work into workgroups, some unnecessary threads are launched.
    //  We terminate those threads here. 
    if(gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= height)
        return;

    float x = float(gl_GlobalInvocationID.x) / float(width);
    float y = float(gl_GlobalInvocationID.y) / float(height);

    // Render each tile in a different color, with red outline
    vec4 color;
    if (ubo.monochrome)
        color = vec4(x*y, x*y, x*y, 1);
    else
        color = vec4(255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 255.0 * float(gl_WorkGroupID.y) / float(gl_NumWorkGroups.y), 255.0 * float(gl_WorkGroupID.x) / float(gl_NumWorkGroups.x), 1);

    if (ubo.debug && (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.y == 0))
    {
        color = vec4(255, 0, 0, 1);
    }

    // Apply 2.0 Gamma correction
    if (ubo.applyGammaCorrection)
        color = vec4( sqrt( color.r ), sqrt( color.g ), sqrt( color.b ), 1.0 );

    // Test for bad struct alignment (happens if the programmer forgets to align every field)
    if (ubo.magic != 0xDEADBEEF)
        color = vec4(1,0,1,1);

    imageData[width * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x].rgba = color;
}
